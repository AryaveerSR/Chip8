use chip8::Chip;
use minifb::{Key, Scale, Window, WindowOptions};

// 10:1 scaling
const WIDTH: usize = 64;
const HEIGHT: usize = 32;

const IBM: [u8; 132] = [
    0x0, 0xe0, 0xa2, 0x2a, 0x60, 0xc, 0x61, 0x8, 0xd0, 0x1f, 0x70, 0x9, 0xa2, 0x39, 0xd0, 0x1f,
    0xa2, 0x48, 0x70, 0x8, 0xd0, 0x1f, 0x70, 0x4, 0xa2, 0x57, 0xd0, 0x1f, 0x70, 0x8, 0xa2, 0x66,
    0xd0, 0x1f, 0x70, 0x8, 0xa2, 0x75, 0xd0, 0x1f, 0x12, 0x28, 0xff, 0x0, 0xff, 0x0, 0x3c, 0x0,
    0x3c, 0x0, 0x3c, 0x0, 0x3c, 0x0, 0xff, 0x0, 0xff, 0xff, 0x0, 0xff, 0x0, 0x38, 0x0, 0x3f, 0x0,
    0x3f, 0x0, 0x38, 0x0, 0xff, 0x0, 0xff, 0x80, 0x0, 0xe0, 0x0, 0xe0, 0x0, 0x80, 0x0, 0x80, 0x0,
    0xe0, 0x0, 0xe0, 0x0, 0x80, 0xf8, 0x0, 0xfc, 0x0, 0x3e, 0x0, 0x3f, 0x0, 0x3b, 0x0, 0x39, 0x0,
    0xf8, 0x0, 0xf8, 0x3, 0x0, 0x7, 0x0, 0xf, 0x0, 0xbf, 0x0, 0xfb, 0x0, 0xf3, 0x0, 0xe3, 0x0,
    0x43, 0xe0, 0x0, 0xe0, 0x0, 0x80, 0x0, 0x80, 0x0, 0x80, 0x0, 0x80, 0x0, 0xe0, 0x0, 0xe0,
];

const sample: [u8; 14] = [
    0x00, 0xE0, 0x60, 0x01, 0x61, 0x01, 0x62, 0x04, 0xF2, 0x29, 0xD0, 0x15, 0x12, 0x0E,
];
const WHITE: u32 = 0x0FFF;
const BLACK: u32 = 0x0000;
fn main() {
    let mut buffer: Vec<u32> = vec![BLACK; WIDTH * HEIGHT];
    let program = IBM.to_vec();

    let mut chip = Chip::new(program);

    let mut opts = WindowOptions::default();
    opts.scale = Scale::X8;

    let mut window = Window::new("Test - ESC to exit", WIDTH, HEIGHT, opts).unwrap_or_else(|e| {
        panic!("{}", e);
    });

    window.limit_update_rate(Some(std::time::Duration::from_micros(16600)));

    while window.is_open() && !window.is_key_down(Key::Escape) {
        if chip.process_instruction() {
            buffer = chip
                .display()
                .iter()
                .flatten()
                .map(|x| if *x { WHITE } else { BLACK })
                .collect();
            //println!("{:?}", chip);
        }

        window.update_with_buffer(&buffer, WIDTH, HEIGHT).unwrap();
    }
}
